# Session: 2026-02-28 - Instance-Scoped API & Lazy Browser Init

## Major Decisions Made

### 1. Instance-Scoped API Architecture
- **Decision**: Move from ambiguous `/navigate` endpoints to explicit instance-scoped paths
- **Pattern**: `/instances/{id}/navigate`, `/instances/{id}/snapshot`, `/instances/{id}/tabs/{id}/navigate`
- **Rationale**: Clear routing, multi-agent safety, no ambiguity about which instance handles requests
- **Benefit**: Each agent gets isolated browser with own cookies, history, profile, and headless/headed mode

### 2. Browser Initialization on Instance Creation
- **Decision**: Start Chrome synchronously when instance is created via POST /instances
- **Timing**: Instance POST request returns only after Chrome is fully initialized
- **Implementation**: Orchestrator calls bridge initialization functions during instance startup
- **Headed/Headless**: Respects instance's `headless` flag from config (headless=false = visible window opens)
- **Benefit**: Predictable behavior, Chrome ready immediately for all subsequent operations, cleaner API semantics
- **Pattern**: POST /instances creates + starts â†’ instance is ready to use â†’ subsequent operations are fast

### 3. Force Tab Creation on Navigate
- **Decision**: `/instances/{id}/navigate` ALWAYS creates new tab
- **Alternative Endpoint**: `/instances/{id}/tabs/{id}/navigate` for reusing existing tabs
- **Rationale**: Simpler API, predictable behavior, matches agent expectations
- **Flexibility**: Advanced agents can still reuse tabs via explicit endpoint

### 4. Remove BRIDGE_NO_DASHBOARD
- **Decision**: Removed unused environment variable from orchestrator and handlers
- **Reason**: All instances now run unified `runDashboard()` code
- **Cleanup**: Removed from orchestrator.Launch(), handlers.go, profiles.js, main.go
- **Result**: Simpler codebase, fewer flags to track

## Architecture Improvements

### Instance Hierarchy
```
Dashboard (9867) manages:
  â”œâ”€ Instance 1 (port 9868, profile=work, headless=false)
  â”‚   â”œâ”€ Chrome (lazy-init on first request)
  â”‚   â””â”€ Tabs (managed independently)
  â”œâ”€ Instance 2 (port 9869, profile=scraping, headless=true)
  â”‚   â””â”€ Tabs (managed independently)
```

### Browser Start Differences
- **Headed vs Headless**: Controlled via `buildChromeOpts()` in `browser.go`
  - Headless: `chromedp.Headless` flag
  - Headed: `chromedp.Flag("headless", false)` (shows visible window)
- **Both use same code path**: Lazy init in `Bridge.EnsureChrome()`

### Code Responsible
- `cmd/pinchtab/browser.go`: `setupAllocator()`, `buildChromeOpts()`, `startChrome()`
- `internal/bridge/bridge.go`: Will add `EnsureChrome()` method
- `internal/handlers/handlers.go`: Call `EnsureChrome()` on first browser request

## Documents Created

### docs/references/endpoints.md (770 lines)
- Complete HTTP API reference for instance-scoped design
- All endpoints with curl examples
- Full agent workflow example (bash script)
- Architecture diagrams
- Error responses and auth
- CLI equivalents
- Key design principles

## Branch Status
- **Branch**: `feat/make-cli-useful`
- **Recent commits**:
  - `5a15688` - docs: add comprehensive api endpoints reference
  - `54ad6e3` - refactor: remove unused BRIDGE_NO_DASHBOARD
  - `912a0c6` - fix: handle array response from /instances
  - `6725ca8` - style: center empty state on instances/profiles screens
  - `807c7f9` - feat: add instances screen to dashboard web ui
  - `c8df419` - feat: add instances screen to dashboard web ui

## Implementation Progress

### âœ… Phase 1: Infrastructure (COMPLETED - Commit bdccfbe)
- âœ… Added sync.Mutex and initialized flag to Bridge
- âœ… Added AllocCancel and BrowserCancel to Bridge
- âœ… Created SetBrowserContexts() method to set contexts after init
- âœ… Modified Bridge.New() to accept nil contexts for lazy instances
- âœ… Deferred TabManager initialization until browser ready
- âœ… Created EnsureChrome() method stub
- âœ… All tests passing (192+ tests)

### âœ… Phase 2: Browser Initialization at Instance Creation (COMPLETED)

#### Phase 2 Part 1 (Commit 56491d2) - Chrome Init Functions
- âœ… Created internal/bridge/init.go with InitChrome() function
- âœ… Extracted setupAllocator() from cmd/pinchtab/browser.go
- âœ… Extracted startChrome() from cmd/pinchtab/browser.go
- âœ… InitChrome() returns 4 contexts: allocCtx, allocCancel, browserCtx, browserCancel
- âœ… Implemented Bridge.EnsureChrome() to call InitChrome()
- âœ… TabManager initialization deferred until Chrome is ready
- âœ… All tests passing (192+ tests)

#### Phase 2 Part 2 (Commit a4ec3ee) - Handler Integration
- âœ… Added EnsureChrome() to BridgeAPI interface
- âœ… Added ensureChrome() helper method to Handlers
- âœ… Updated HandleNavigate to call ensureChrome()
- âœ… Updated HandleSnapshot to call ensureChrome()
- âœ… Updated HandleAction and HandleActions to call ensureChrome()
- âœ… Updated HandleScreenshot to call ensureChrome()
- âœ… Updated HandlePDF to call ensureChrome()
- âœ… Updated HandleText to call ensureChrome()
- âœ… Updated all test mocks to implement EnsureChrome()
- âœ… All 195+ tests passing
- âœ… All pre-commit checks passing

### ðŸ“‹ Phase 3: Instance-Scoped Endpoints (NEXT - Estimated 3-4 commits)
1. **Create bridge initialization in orchestrator**
   - When instance.Launch() creates a new Pinchtab process via runner
   - After process starts listening on port, orchestrator must:
     a. Allocate Chrome allocator (setupAllocator from browser.go)
     b. Start Chrome browser (startChrome with headless/headed flags)
     c. Call bridge.SetBrowserContexts() to register the contexts
   - Wait for Chrome initialization to complete before returning from /instances POST

2. **Refactor browser.go initialization code**
   - Extract setupAllocator(), buildChromeOpts(), startChrome() to package-level functions in internal/bridge
   - Or create InitChrome(cfg *config.RuntimeConfig) (*context.Context, *context.Context, error) helper
   - Make it callable from orchestrator

3. **Update orchestrator instance launch flow**
   - POST /instances endpoint calls orchestrator.Launch()
   - orchestrator.Launch() spawns instance process
   - orchestrator waits for instance health check
   - orchestrator initializes Chrome using the extracted helper
   - orchestrator returns initialized instance with Chrome running

### ðŸ“‹ Phase 3: Instance-Scoped Endpoints (NEXT - Estimated 3-4 commits)

**Key insight**: Each instance already runs on its own port (9868, 9869, etc.) with its own Bridge.
The handler routes on that port don't need `/instances/{id}` prefix - just register at `/navigate`, `/snapshot`, etc.
Requests to port 9868 automatically go to that instance's Bridge.

1. **Verify instance-port mapping works**
   - Each spawned instance already on separate port âœ“
   - Each port gets its own Bridge instance âœ“
   - Routes on that Bridge's handlers.go are isolated âœ“

2. **Backward-compat routes on dashboard (port 9867)**
   - Dashboard port 9867 runs its own handlers
   - Could keep old `/navigate`, `/snapshot`, etc. routing to orchestrator's default instance
   - Or update CLI to use specific instance port directly

3. **Testing approach**
   - Create instance via POST http://localhost:9867/instances â†’ returns port (e.g., 9868)
   - Navigate via POST http://localhost:9868/navigate
   - No need for `/instances/{id}` prefix - port already targets instance
   - Dashboard can proxy to instance ports if needed for UI

### ðŸ“‹ Phase 4: Orchestrator Integration (Phase 3 continuation - Estimated 2-3 commits)

**Goal**: Make POST /instances call Chrome initialization

1. **Update orchestrator.Launch() to initialize Chrome**
   - After spawning instance process
   - After health check passes
   - Call bridge.InitChrome() for that instance
   - Return initialized instance with Chrome running

2. **Test POST /instances endpoint**
   - Create instance with {profile: "work", headless: false}
   - Verify Chrome window opens (headless=false)
   - Verify returned instance has port and status="running"
   - Verify subsequent POST /navigate works immediately

3. **Test headless instances**
   - Create instance with headless=true
   - Verify no Chrome window
   - Verify Chrome still responds to navigate/snapshot calls

### ðŸ“‹ Phase 5: Testing & Validation (After Phase 4)
1. **Test headed vs headless**
   - Launch instance with headless=false â†’ Chrome window should appear
   - Launch instance with headless=true â†’ No window
   
2. **Test tab creation timing**
   - Create instance â†’ no Chrome running yet
   - POST /instances/{id}/navigate â†’ Chrome starts, navigates
   - Subsequent requests reuse browser

3. **Multi-agent isolation**
   - Agent A: instance-a-work (headless=false, profile=work)
   - Agent B: instance-b-scrape (headless=true, profile=scraping)
   - Verify no state leakage between instances

4. **Test lazy init**
   - Create 10 instances â†’ none start Chrome
   - POST navigate to 3 of them â†’ only 3 have running Chrome
   - POST navigate to remaining 7 â†’ browsers start on first request

## Key Insights

- **Browser.go is mature**: All logic for headed/headless already exists; can be extracted for reuse
- **Instance isolation**: Each instance gets own allocCtx + browserCtx on creation; no shared state between instances
- **Headless flag is config**: Set at instance launch time via POST request; controls Chrome flags automatically
- **Tab creation is stateful**: Navigate creates new tab; reuse tab via explicit `/instances/{id}/tabs/{id}/navigate` endpoint
- **API design is hierarchical**: `/instances` (create/list) â†’ `/instances/{id}` (info/operate) â†’ `/instances/{id}/tabs/{id}` (specific tab)
- **Chrome starts upfront**: No lazy init - POST /instances returns only after Chrome fully initialized
- **Cleaner semantics**: Instance is immediately ready to use; no "wait for browser" surprise later
- **Orchestrator role**: Manages instance lifecycle including browser initialization and shutdown

## Blocked/Open Questions

- None identified; design is solid and ready to implement

## Files Modified in Session
- Created: `docs/references/endpoints.md`
- Created: (planned) `internal/bridge/chrome/init.go`
- Edited: `cmd/pinchtab/main.go`, `internal/orchestrator/orchestrator.go`, `internal/handlers/handlers.go`, `internal/dashboard/dashboard/profiles.js`
- Edited: `internal/bridge/bridge.go` (added lazy init infrastructure)

## Code Changes in Phase 1 (Commit bdccfbe)
- **internal/bridge/bridge.go**: Added fields and methods for lazy initialization
  - Added imports: `sync`
  - Added to Bridge struct: `initMu`, `AllocCancel`, `BrowserCancel`, `initialized`
  - Modified `New()` to accept nil contexts
  - Added `EnsureChrome()` method (stub)
  - Added `SetBrowserContexts()` method (implementation ready)
  - TabManager initialization now deferred until browser context available

## Key Code Locations for Phase 2
- Browser startup logic: `cmd/pinchtab/browser.go` (lines 17-85)
  - `setupAllocator()` - creates Chrome allocator
  - `buildChromeOpts()` - builds Chrome flags  
  - `startChrome()` - starts browser context
- Handler registration: `internal/handlers/handlers.go` (RegisterRoutes)
- Dashboard initialization: `cmd/pinchtab/cmd_dashboard.go` (runDashboard function)
