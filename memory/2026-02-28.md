# Session: 2026-02-28 - Instance-Scoped API & Lazy Browser Init

## Major Decisions Made

### 1. Instance-Scoped API Architecture
- **Decision**: Move from ambiguous `/navigate` endpoints to explicit instance-scoped paths
- **Pattern**: `/instances/{id}/navigate`, `/instances/{id}/snapshot`, `/instances/{id}/tabs/{id}/navigate`
- **Rationale**: Clear routing, multi-agent safety, no ambiguity about which instance handles requests
- **Benefit**: Each agent gets isolated browser with own cookies, history, profile, and headless/headed mode

### 2. Browser Initialization on Instance Creation
- **Decision**: Start Chrome synchronously when instance is created via POST /instances
- **Timing**: Instance POST request returns only after Chrome is fully initialized
- **Implementation**: Orchestrator calls bridge initialization functions during instance startup
- **Headed/Headless**: Respects instance's `headless` flag from config (headless=false = visible window opens)
- **Benefit**: Predictable behavior, Chrome ready immediately for all subsequent operations, cleaner API semantics
- **Pattern**: POST /instances creates + starts â†’ instance is ready to use â†’ subsequent operations are fast

### 3. Force Tab Creation on Navigate
- **Decision**: `/instances/{id}/navigate` ALWAYS creates new tab
- **Alternative Endpoint**: `/instances/{id}/tabs/{id}/navigate` for reusing existing tabs
- **Rationale**: Simpler API, predictable behavior, matches agent expectations
- **Flexibility**: Advanced agents can still reuse tabs via explicit endpoint

### 4. Remove BRIDGE_NO_DASHBOARD
- **Decision**: Removed unused environment variable from orchestrator and handlers
- **Reason**: All instances now run unified `runDashboard()` code
- **Cleanup**: Removed from orchestrator.Launch(), handlers.go, profiles.js, main.go
- **Result**: Simpler codebase, fewer flags to track

### 5. Configurable Port Ranges for Instance Allocation
- **Decision**: Add environment variables for instance port range management
- **Implementation**:
  - `INSTANCE_PORT_START` (default 9868) - first available instance port
  - `INSTANCE_PORT_END` (default 9968) - last available instance port (100 instances max by default)
  - `BRIDGE_PORT` (default 9867) - dashboard/orchestrator port (existing, already configurable)
- **Port Allocator**: New utility to track and allocate ports within range
  - Thread-safe with mutex
  - Auto-detects available ports and skips in-use ones
  - Supports unlimited instances if port range is large enough
  - Can be configured per deployment (Docker, K8s, etc.)
- **Rationale**: Clean separation of dashboard vs instances, enables multi-deployment scenarios

## Architecture Improvements

### Instance Hierarchy
```
Dashboard (9867) manages:
  â”œâ”€ Instance 1 (port 9868, profile=work, headless=false)
  â”‚   â”œâ”€ Chrome (lazy-init on first request)
  â”‚   â””â”€ Tabs (managed independently)
  â”œâ”€ Instance 2 (port 9869, profile=scraping, headless=true)
  â”‚   â””â”€ Tabs (managed independently)
```

### Browser Start Differences
- **Headed vs Headless**: Controlled via `buildChromeOpts()` in `browser.go`
  - Headless: `chromedp.Headless` flag
  - Headed: `chromedp.Flag("headless", false)` (shows visible window)
- **Both use same code path**: Lazy init in `Bridge.EnsureChrome()`

### Code Responsible
- `cmd/pinchtab/browser.go`: `setupAllocator()`, `buildChromeOpts()`, `startChrome()`
- `internal/bridge/bridge.go`: Will add `EnsureChrome()` method
- `internal/handlers/handlers.go`: Call `EnsureChrome()` on first browser request

## Documents Created

### docs/references/endpoints.md (770 lines)
- Complete HTTP API reference for instance-scoped design
- All endpoints with curl examples
- Full agent workflow example (bash script)
- Architecture diagrams
- Error responses and auth
- CLI equivalents
- Key design principles

## Branch Status
- **Branch**: `feat/make-cli-useful`
- **Recent commits**:
  - `a0b527e` - feat: add configurable port ranges for instance allocation
  - `ddfa0ed` - docs: update memory with Phase 2 completion and Phase 3-5 planning
  - `a4ec3ee` - feat: update handlers to ensure Chrome initialization (Phase 2 Part 2)
  - `56491d2` - feat: implement Chrome initialization (Phase 2 Part 1)
  - `1130a3f` - docs: update to reflect Chrome initialization on instance creation
  - `bdccfbe` - feat: add lazy browser initialization infrastructure to Bridge

## Implementation Progress

### âœ… Phase 1: Infrastructure (COMPLETED - Commit bdccfbe)
- âœ… Added sync.Mutex and initialized flag to Bridge
- âœ… Added AllocCancel and BrowserCancel to Bridge
- âœ… Created SetBrowserContexts() method to set contexts after init
- âœ… Modified Bridge.New() to accept nil contexts for lazy instances
- âœ… Deferred TabManager initialization until browser ready
- âœ… Created EnsureChrome() method stub
- âœ… All tests passing (192+ tests)

### âœ… Phase 2: Browser Initialization at Instance Creation (COMPLETED)

### âœ… Phase 2.5: Port Allocation System (COMPLETED - Commit a0b527e)

**What was added:**
- **internal/config/config.go** - Added InstancePortStart and InstancePortEnd to RuntimeConfig
- **internal/orchestrator/ports.go** - New PortAllocator utility (119 lines)
- **internal/orchestrator/orchestrator.go** - Integrated PortAllocator into Orchestrator
- **cmd/pinchtab/cmd_dashboard.go** - Call SetPortRange() during dashboard init

**PortAllocator features:**
- `AllocatePort()` - Finds next available port in configured range
- `ReleasePort(port)` - Marks port as no longer allocated
- `IsAllocated(port)` - Check allocation status
- `AllocatedPorts()` - List all allocated ports
- Thread-safe with sync.Mutex
- Wraps around if reaches end of range
- Actually checks port availability (doesn't just track allocation)

**Configuration:**
- Env vars: INSTANCE_PORT_START, INSTANCE_PORT_END
- File config support: instancePortStart, instancePortEnd in config.json
- Defaults: 9868-9968 (100 instance slots)
- All env vars override file config

**Use Cases Enabled:**
1. Multiple dashboards on different machines/ports
2. Containerized deployments with port ranges
3. Development: 9867 dashboard, 9868-9900 instances
4. Production: 9867 dashboard, 9868-10000 instances (133 instances)
5. Kubernetes: Different port ranges per deployment

### âœ… Phase 2: Browser Initialization at Instance Creation (COMPLETED)

#### Phase 2 Part 1 (Commit 56491d2) - Chrome Init Functions
- âœ… Created internal/bridge/init.go with InitChrome() function
- âœ… Extracted setupAllocator() from cmd/pinchtab/browser.go
- âœ… Extracted startChrome() from cmd/pinchtab/browser.go
- âœ… InitChrome() returns 4 contexts: allocCtx, allocCancel, browserCtx, browserCancel
- âœ… Implemented Bridge.EnsureChrome() to call InitChrome()
- âœ… TabManager initialization deferred until Chrome is ready
- âœ… All tests passing (192+ tests)

#### Phase 2 Part 2 (Commit a4ec3ee) - Handler Integration
- âœ… Added EnsureChrome() to BridgeAPI interface
- âœ… Added ensureChrome() helper method to Handlers
- âœ… Updated HandleNavigate to call ensureChrome()
- âœ… Updated HandleSnapshot to call ensureChrome()
- âœ… Updated HandleAction and HandleActions to call ensureChrome()
- âœ… Updated HandleScreenshot to call ensureChrome()
- âœ… Updated HandlePDF to call ensureChrome()
- âœ… Updated HandleText to call ensureChrome()
- âœ… Updated all test mocks to implement EnsureChrome()
- âœ… All 195+ tests passing
- âœ… All pre-commit checks passing

### ðŸ“‹ Phase 3: Auto-Port Allocation in Orchestrator (NEXT - Estimated 1-2 commits)

**Goal**: Use PortAllocator when launching instances instead of requiring manual port specification

1. **Update orchestrator.Launch()**
   - If port parameter is empty, call `o.portAllocator.AllocatePort()`
   - Return allocated port to caller
   - On instance shutdown/failure, call `o.portAllocator.ReleasePort(port)`

2. **Update orchestrator handlers** (/instances POST endpoint)
   - Accept optional port in request body
   - If port provided, use it (manual override)
   - If not provided, auto-allocate
   - Return allocated port in response

3. **Wire handler to use allocator**
   - orchestrator/handlers.go CreateInstance() should:
     a. Extract port from request (optional)
     b. Call orchestrator.Launch(name, port, headless)
     c. If Launch succeeds, return instance with port

4. **Testing**
   - POST /instances with no port â†’ should auto-allocate (9868)
   - POST /instances 5 times â†’ should get 9868, 9869, 9870, 9871, 9872
   - Verify PortAllocator tracks them
   - Clean shutdown â†’ ports released and reusable

### ðŸ“‹ Phase 4: Instance-Scoped Endpoints (After Phase 3 - Estimated 3-4 commits)

**Key insight**: Each instance already runs on its own port (9868, 9869, etc.) with its own Bridge.
The handler routes on that port don't need `/instances/{id}` prefix - just register at `/navigate`, `/snapshot`, etc.
Requests to port 9868 automatically go to that instance's Bridge.

1. **Verify instance-port mapping works**
   - Each spawned instance already on separate port âœ“
   - Each port gets its own Bridge instance âœ“
   - Routes on that Bridge's handlers.go are isolated âœ“

2. **Update CLI to use specific instance port**
   - CLI commands should target instance port directly
   - Or query orchestrator for first running instance
   - Dashboard can proxy to instance ports if needed for UI

3. **Testing approach**
   - Create instance via POST http://localhost:9867/instances â†’ returns port (e.g., 9868)
   - Navigate via POST http://localhost:9868/navigate
   - Port already targets instance (no path prefix needed)

### ðŸ“‹ Phase 5: Orchestrator Chrome Initialization (After Phase 4 - Estimated 2-3 commits)

**Goal**: Initialize Chrome when instances are created (POST /instances)

1. **Update orchestrator instance launch flow**
   - After instance process starts and passes health check
   - Call bridge.InitChrome() via HTTP request to instance
   - Instance calls bridge.EnsureChrome() which runs InitChrome()
   - Wait for Chrome to fully initialize
   - Return instance with Chrome ready

2. **Test POST /instances endpoint**
   - Create instance with {profile: "work", headless: false}
   - Verify Chrome window opens (headless=false)
   - Verify returned instance has port, status="running", tabs=[]
   - Verify subsequent POST /navigate works immediately (Chrome already running)

3. **Test headless instances**
   - Create instance with {headless: true}
   - Verify no Chrome window visible
   - Verify POST /navigate still works (Chrome running in background)

4. **Test auto-port + Chrome init flow**
   - POST /instances (no port) â†’ auto-allocate 9868, start Chrome
   - POST /instances (no port) â†’ auto-allocate 9869, start Chrome
   - Both instances ready immediately
   - No race conditions or port conflicts

### ðŸ“‹ Phase 6: Testing & Validation (After Phase 5)
1. **Test headed vs headless**
   - Create instance {headless: false} â†’ Chrome window appears
   - Create instance {headless: true} â†’ No window, runs in background
   - Both work identically except visibility
   
2. **Multi-instance coordination**
   - Create 3 instances simultaneously
   - Each gets different port (9868, 9869, 9870)
   - Each has independent Chrome with own cookies/history
   - No state leakage between instances

3. **Multi-agent isolation**
   - Agent A: targets http://localhost:9868/navigate (work profile)
   - Agent B: targets http://localhost:9869/navigate (scraping profile)
   - Agent C: targets http://localhost:9870/navigate (another profile)
   - Verify each agent only sees its own instance's data

4. **Dashboard-to-instance communication**
   - Dashboard (9867) lists instances
   - Dashboard proxies requests to instance ports
   - UI shows instance status, tabs, resources
   - Can terminate instances and release ports

### ðŸ“‹ Phase 7: CLI & Documentation (After Phase 6)

1. **Update CLI to use auto-allocation**
   - `pinchtab instances new --profile work --headless=false`
   - Should create instance, auto-allocate port, start Chrome
   - Print port to stdout for use in scripts

2. **Update documentation**
   - docs/get-started.md: Multi-instance workflow
   - docs/references/endpoints.md: Auto-allocation details
   - docs/architecture/: Instance lifecycle diagram

3. **Add example workflows**
   - Multi-agent scraping with dedicated instances
   - Load distribution across headless instances
   - Clean startup/shutdown with port cleanup

## Key Insights

- **Browser.go is mature**: All logic for headed/headless already exists; can be extracted for reuse
- **Instance isolation**: Each instance gets own allocCtx + browserCtx on creation; no shared state between instances
- **Headless flag is config**: Set at instance launch time via POST request; controls Chrome flags automatically
- **Tab creation is stateful**: Navigate creates new tab; reuse tab via explicit `/instances/{id}/tabs/{id}/navigate` endpoint
- **API design is hierarchical**: `/instances` (create/list) â†’ `/instances/{id}` (info/operate) â†’ `/instances/{id}/tabs/{id}` (specific tab)
- **Chrome starts upfront**: No lazy init - POST /instances returns only after Chrome fully initialized
- **Cleaner semantics**: Instance is immediately ready to use; no "wait for browser" surprise later
- **Orchestrator role**: Manages instance lifecycle including browser initialization and shutdown

## Blocked/Open Questions

- None identified; design is solid and ready to implement

## Files Modified in Session
- Created: `docs/references/endpoints.md`
- Created: (planned) `internal/bridge/chrome/init.go`
- Edited: `cmd/pinchtab/main.go`, `internal/orchestrator/orchestrator.go`, `internal/handlers/handlers.go`, `internal/dashboard/dashboard/profiles.js`
- Edited: `internal/bridge/bridge.go` (added lazy init infrastructure)

## Code Changes in Phase 1 (Commit bdccfbe)
- **internal/bridge/bridge.go**: Added fields and methods for lazy initialization
  - Added imports: `sync`
  - Added to Bridge struct: `initMu`, `AllocCancel`, `BrowserCancel`, `initialized`
  - Modified `New()` to accept nil contexts
  - Added `EnsureChrome()` method (stub)
  - Added `SetBrowserContexts()` method (implementation ready)
  - TabManager initialization now deferred until browser context available

## Key Code Locations for Phase 2
- Browser startup logic: `cmd/pinchtab/browser.go` (lines 17-85)
  - `setupAllocator()` - creates Chrome allocator
  - `buildChromeOpts()` - builds Chrome flags  
  - `startChrome()` - starts browser context
- Handler registration: `internal/handlers/handlers.go` (RegisterRoutes)
- Dashboard initialization: `cmd/pinchtab/cmd_dashboard.go` (runDashboard function)
